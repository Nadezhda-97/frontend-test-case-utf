## Изменения в App.jsx

#### 1. Основная логика вынесена в компоненты
**Проблема**:
- Весь функционал приложения был сосредоточен в одном файле App.jsx.
- Несколько уровней ответственности смешаны вместе: инициализация приложения (Provider), логика работы каталога и корзины, загрузка данных, UI-компоненты, сайд-эффекты (setTimeout, alert)

**Решение**:
- Вынесена логика работы каталога, корзины и отдельные компоненты в папку components.
- App.jsx теперь содержит только главный компонент `App` и инициализацию приложения через Provider.
- Компоненты, такие как `Header`, `ProductList` и `Cart`, теперь загружаются из папки `components`.

**Почему**:
- Уменьшена сложность и улучшена читаемость кода.
- Каждая часть приложения отвечает за свою отдельную функциональность (разделение ответственности).
- Компоненты стали переиспользуемыми и проще тестируемыми.

Примерная новая структура проекта:
```
src/
  components/
    Header.jsx
    ProductList.jsx
    Cart.jsx
  App.jsx
  store/
    store.js
```

#### 2. Создание компонента AppContent для UI и логики приложения
**Что сделали**:
Разделили App на два компонента:
1. App — только обёртка Provider для Redux.
2. AppContent — весь UI и логика приложения (инициализация пользователя, получение данных из Redux).

В AppContent используем `useDispatch` и `useSelector` для работы с состоянием пользователя; добавляем `useEffect` с таймером для имитации загрузки пользователя; передаём `user` и `isLoading` в компонент `Header` через пропсы.

**Почему**:
1. Хуки Redux (useSelector, useDispatch) могут вызываться только внутри компонента, который находится под Provider.
2. Provider нельзя оставлять внутри компонента, который использует эти хуки — иначе будет ошибка.
3. Вынос логики в `AppContent` позволяет сохранить `Header` чистым UI-компонентом, правильно управлять состоянием пользователя, легко заменять имитацию загрузки на реальный API в будущем.


## Изменения в Header.jsx
**Что сделали**:
1. Вынесли из `Header` всю бизнес-логику и работу с Redux.
2. Оставили только JSX-разметку (логотип, блок с пользователем) и условный рендеринг состояния загрузки (```isLoading ? "Загрузка..." : "Привет, {user.name}"```).

**Почему**:
1. `Header` — это UI-компонент, его задача только отображать данные, а не получать или изменять их.
2. Работа с пользователем, диспатч экшенов, таймеры — это бизнес-логика, которая не относится к отображению.
3. Такой подход снижает связность компонентов, упрощает тестирование и повторное использование Header в будущем.

## Изменения в ProductsList.jsx
#### 1. Вынесены моковые данные товаров в отдельный файл
**Что сделано**:
Массив `mockProducts` был вынесен из компонента `ProductList` в отдельный файл ```src/mocks/products.js```.

**Почему**:
- Компонент перестал содержать данные и стал отвечать только за их отображение.
- Уменьшилась связность UI и источника данных.
- Упростилась замена моков на реальный API в будущем.

#### 2. Логика загрузки товаров вынесена в отдельный модуль (МОЖНО ОБЪЕДИНИТЬ С ПУНКТОМ 5)
**Что сделано**:
Создан файл ```src/api/products.js``` с функцией `fetchProductsMock`, которая имитирует асинхронную загрузку товаров.

**Почему**:
- Убран `setTimeout` из компонента — бизнес-логика больше не находится внутри UI.
- Компонент теперь работает с абстракцией загрузки данных, а не с конкретной реализацией.
- Подготовлена база для перехода на реальные HTTP-запросы или RTK Query.

#### 3. Карточка товара вынесена в отдельный компонент `ProductCard`
**Что сделано**:
Разметка и логика отображения одного товара вынесены в компонент `ProductCard`.

**Почему**:
- Уменьшен размер и сложность `ProductList`.
- Повышена переиспользуемость карточки товара.
- Локализована логика добавления товара в корзину.
- Компоненты стали более изолированными и тестируемыми.

#### 4. Логика обработчика клика вынесена в отдельную функцию
**Что сделано**:
В компоненте карточки товара логика добавления товара в корзину была вынесена из inline-обработчика `onClick` в отдельную функцию `handleAddToCart`.
Было:
```
<button
  onClick={() => {
    const action = { type: 'app/addToCart', payload: product }
    dispatch(action)
  }}
>
  Добавить в корзину
</button>
```
Стало:
Логика dispatch перенесена в отдельную функцию-обработчик, которая передаётся в `onClick`.

**Почему**:
- Убрана бизнес-логика из JSX.
- Улучшена читаемость разметки.
- Код стал проще поддерживать и расширять (например, добавление аналитики, disable-кнопки, уведомлений).
- Следование best practices React: обработчики событий выносятся в функции, а не описываются inline.

#### 5. Асинхронная загрузка товаров вынесена в thunk
**Что сделано**:
- Логика асинхронной загрузки товаров была вынесена из компонента `ProductList` в отдельный thunk `fetchProducts`.
- Компонент `ProductList` больше не управляет состоянием загрузки (loading) напрямую и лишь инициирует процесс загрузки данных через ```dispatch(fetchProducts())```.

Было (примерно):
```
useEffect(() => {
    dispatch(setLoading(true))
    setTimeout(() => {
      dispatch(setProducts(mockProducts))
      dispatch(setLoading(false))
    }, 1000)
  }, [dispatch])
```
В компоненте ProductList выполнялась асинхронная логика:
- установка loading;
- вызов функции загрузки; (или просто загрузка данных и сохранение их в стор)
- сохранение данных в store;
- сброс loading

Стало:
```
useEffect(() => {
    dispatch(fetchProducts());
  }, [dispatch]);
```
Вся логика загрузки данных (установка loading, обработка успешного ответа и ошибок) сосредоточена в thunk. Компонент`ProductList` теперь отвечает только за отображение UI и инициацию загрузки данных.

**Почему**:
- Компонент перестал содержать бизнес-логику.
- Логика загрузки данных централизована и может быть переиспользована в других компонентах.
- Состояние loading и error логически относится к данным и должно управляться на уровне Redux, а не UI.
- Упрощается дальнейшее расширение функциональности (обработка ошибок, повторные запросы, замена моков на реальный API).

#### 6. Реализована работа кнопки «Показать/Скрыть фильтры»
**Что сделано**:
- В компоненте `ProductList` добавлена логика, при которой блок фильтров отображается, только если состояние `showFilters` равно true.
- Кнопка переключает состояние `showFilters`, а сам блок фильтров обёрнут в условие ```{showFilters && (...)}```.

**Почему**:
- Улучшена интерактивность интерфейса.
- Логика состояния теперь реально влияет на отображение, а не только на текст кнопки.

**Было**:
- Кнопка меняла текст («Показать фильтры» / «Скрыть фильтры»), но сам блок фильтров всегда оставался видимым.
- Состояние showFilters не влияло на разметку.

**Стало**:
- Блок фильтров реально скрывается и показывается в зависимости от showFilters.
- Кнопка полностью управляет видимостью фильтров.

#### 7. Фильтрация и сортировка товаров вынесена в селектор Redux
**Что сделано**:
- Логика фильтрации и сортировки товаров была вынесена из компонента `ProductList` в отдельный селектор `selectFilteredProducts` (используя `createSelector` из Redux Toolkit).
- Компонент теперь получает уже готовый список отфильтрованных товаров `filteredProducts` через `useSelector` и не выполняет фильтрацию и сортировку сам.

**Почему**:
- Повысить производительность (фильтрация и сортировка не выполняются на каждый рендер).
- Улучшить масштабируемость (селектор можно использовать на разных страницах и с большим количеством товаров).
- Компонент стал отвечать только за отображение UI.
- Код стал более читаемым, поддерживаемым и легко тестируемым.


