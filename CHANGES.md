## Изменения в App.jsx

#### 1. Основная логика вынесена в компоненты
**Проблема**:
Весь функционал приложения был сосредоточен в одном файле App.jsx. В результате смешивались разные уровни ответственности: инициализация приложения (`Provider`), логика работы каталога и корзины, загрузка данных, UI-компоненты, сайд-эффекты (`setTimeout`, `alert`).

**Решение**:
Вынести логику работы каталога (`ProductList`), корзины (`Cart`) и отдельные компоненты (`Header`) в папку `components`. App.jsx теперь содержит только обёртку `Provider` и основной компонент приложения.

**Почему**:
- Уменьшена сложность и улучшена читаемость кода.
- Каждая часть приложения отвечает за свою отдельную функциональность (разделение ответственности).
- Компоненты стали переиспользуемыми и проще тестируемыми.

Примерная новая структура проекта:
```
src/
  components/
    Header.jsx
    ProductList.jsx
    Cart.jsx
  App.jsx
  store/
    store.js
```

#### 2. Создание компонента AppContent для UI и логики приложения
**Что сделано**:
App.jsx разделен  на два компонента:
1. `App` - теперь это только обёртка `Provider` для Redux.
2. `AppContent` - теперь содержит весь UI и логику приложения: инициализацию пользователя, получение данных из компонентов`Header`, `ProductList` и `Cart`).

В `AppContent` используется `useDispatch` и `useSelector` для работы с состоянием пользователя; добавляется `useEffect` с таймером для имитации загрузки пользователя; передаётся `user` и `isLoading` в компонент `Header` через пропсы.

**Почему**:
- Redux-хуки (`useSelector`, `useDispatch`) могут вызываться только внутри компонента, который находится под `Provider`.
- `Provider` нельзя оставлять внутри компонента, который использует эти хуки - иначе будет ошибка.
- Вынос логики в `AppContent` позволяет сохранить `Header` чистым UI-компонентом, правильно управлять состоянием пользователя и заменить имитацию загрузки на реальный API в будущем.


## Изменения в Header.jsx
**Что сделано**:
1. Из `Header` вынесена вся бизнес-логика и работа с Redux.
2. Остались только JSX-разметка (логотип, блок с пользователем) и условный рендеринг состояния загрузки 
(```isLoading ? "Загрузка..." : "Привет, {user.name}"```).

**Почему**:
- `Header` - это UI-компонент, его задача только отображать данные, а не получать или изменять их.
- Работа с пользователем, диспатч экшенов, таймеры - это бизнес-логика, которая не относится к отображению.
- Такой подход упрощает тестирование и повторное использование `Header` в будущем.

## Изменения в ProductList.jsx

#### 1. Вынесены моковые данные товаров в отдельный файл
**Что сделано**:
Массив `mockProducts` был вынесен из компонента `ProductList` в отдельный файл ```src/mocks/products.js```.

**Почему**:
- Компонент перестал содержать данные и стал отвечать только за их отображение.
- Упростилась замена моков на реальный API в будущем.

#### 2. Вынесена логика загрузки товаров
**Что сделано**:
1. Создан файл ```src/api/fetchProductsMock.js``` с функцией `fetchProductsMock`, которая имитирует асинхронную загрузку товаров.
2. Логика асинхронной загрузки товаров была вынесена из компонента `ProductList` в отдельный thunk `fetchProducts`.
3. Компонент больше не управляет состоянием загрузки напрямую и лишь инициирует процесс загрузки данных через ```dispatch(fetchProducts())```.

**Было (примерно)**:
```
useEffect(() => {
    dispatch(setLoading(true))
    setTimeout(() => {
      dispatch(setProducts(mockProducts))
      dispatch(setLoading(false))
    }, 1000)
  }, [dispatch])
```

**Стало**:
```
useEffect(() => {
    dispatch(fetchProducts());
  }, [dispatch]);
```

**Почему**:
- Компонент перестал содержать бизнес-логику.
- Логика загрузки данных изолирована и может быть переиспользована в других компонентах.
- Состояние `loading` (и `error`) логически относится к данным и должно управляться на уровне Redux, а не UI.

#### 3. Карточка товара вынесена в отдельный компонент `ProductCard`
**Что сделано**:
Разметка и логика отображения одного товара вынесены в компонент `ProductCard`.

**Почему**:
- Уменьшен размер и сложность `ProductList`.
- Добавлена возможность переиспользовать карточку товара.
- Локализована логика добавления товара в корзину.
- Компоненты стали более изолированными и тестируемыми.

#### 4. Логика обработчика клика вынесена в отдельную функцию
**Что сделано**:
В компоненте карточки товара `ProductCard` логика добавления товара в корзину была вынесена из inline-обработчика `onClick` в отдельную функцию `handleAddToCart`.
**Было**:
```
<button
  onClick={() => {
    const action = { type: 'app/addToCart', payload: product }
    dispatch(action)
  }}
>
  Добавить в корзину
</button>
```
**Стало**:
Логика dispatch перенесена в отдельную функцию-обработчик, которая передаётся в `onClick`.

**Почему**:
- Убрана бизнес-логика из JSX.
- Улучшена читаемость разметки.

#### 5. Реализована работа кнопки «Показать/Скрыть фильтры»
**Что сделано**:
1. В компоненте `ProductList` добавлена логика, при которой блок фильтров отображается, только если состояние `showFilters` равно `true`.
2. Кнопка переключает состояние `showFilters`, а сам блок фильтров обёрнут в условие ```{showFilters && (...)}```.

**Почему**:
- Улучшена интерактивность интерфейса.
- Логика состояния теперь реально влияет на отображение, а не только на текст кнопки.

**Было**:
- Кнопка меняла текст («Показать фильтры» / «Скрыть фильтры»), но сам блок фильтров всегда оставался видимым.
- Состояние `showFilters` не влияло на разметку.

**Стало**:
- Блок фильтров реально скрывается и показывается в зависимости от `showFilters`.
- Кнопка полностью управляет видимостью фильтров.

#### 6. Фильтрация и сортировка товаров вынесена в селектор Redux
**Что сделано**:
1. Логика фильтрации и сортировки товаров была вынесена из компонента `ProductList` в отдельный селектор `selectFilteredProducts` (используя `createSelector` из Redux Toolkit).
2. Компонент теперь получает уже готовый список отфильтрованных товаров `filteredProducts` через `useSelector` и не выполняет фильтрацию и сортировку сам.

**Почему**:
- Повысить производительность (фильтрация и сортировка не выполняются на каждый рендер).
- Улучшить масштабируемость (селектор можно использовать на разных страницах и с большим количеством товаров).
- Компонент стал отвечать только за отображение UI.
- Код стал более читаемым, поддерживаемым и легко тестируемым.

## Изменения в Cart.jsx

#### 1. Элемент содержимого корзины вынесен в отдельный компонент `CartItem`
**Что сделано**:
1. Разметка и логика отображения одного элемента корзины вынесены в компонент `CartItem`.
2. В компоненте `CartItem` логика обработки действий пользователя (увеличение/уменьшение количества) вынесена из JSX в отдельные функции-обработчики.

**Было**:
```
<button onClick={() => handleUpdateQuantity(item.id, item.quantity - 1)}>
```

**Стало**:
```
const handleDecrease = () => onChangeQuantity(id, quantity - 1);
...
<button onClick={handleDecrease}>-</button>
```

**Почему**:
- Снижение ответственности компонента `Cart`: до рефакторинга `Cart` одновременно управлял состоянием, бизнес-логикой и рендером элементов, что усложняло поддержку и чтение кода.
- Улучшение читаемости и структуры: вынос `CartItem` уменьшил объём JSX в Cart.jsx
- Компонент `Cart` больше не отвечает за отображение структуры отдельного товара, а только за получение данных из Redux, управление UI-состоянием корзины и передачу обработчиков в дочерние компоненты.
- Компонент`CartItem` не содержит логики Redux, не знает о структуре стора, получает данные и колбэки через props, является переиспользуемым и изолированным UI-компонентом.

#### 2. Изменение способа получения `cartCount` и `totalPrice`
**Что сделано**:
1. Компонент `Cart` больше не получает `cartCount` и `totalPrice` напрямую из состояния. Для получения количества товаров и общей суммы используются селекторы (`selectCartCount`, `selectTotalPrice`).
2. Компонент теперь работает только с теми данными, которые ему действительно нужны, и не зависит от внутренней структуры Redux store.

**Почему**:
- Компонент стал менее связанным с Redux store.
- Селекторы можно переиспользовать в других компонентах и при необходимости оптимизировать (например, с помощью мемоизации).

#### 3. Замена строковых `dispatch` на action creators
**Что сделано**:
Вместо прямых строковых вызовов экшенов, например:
```
dispatch({ type: 'app/removeFromCart', payload: id })
```
Теперь используются action creators из store.js, например:
```
dispatch(removeFromCart(id));
```

**Почему**:
- Чтобы убрать прямую зависимость от строковых типов экшенов - это снижает риск ошибок при опечатках.
- Код стал более читаемым и сразу видно, какой экшен выполняется.

#### 4. Изменена логика работы функции `handleCheckout`
**Что сделано**:
1. Логика оформления заказа вынесена наружу через колбэк `onCheckout`.
2. В компоненте больше нет `setTimeout` и `alert`.
3. Компонент теперь вызывает колбэк `onCheckout`, который обрабатывает оформление заказа, очищает корзину и показывает уведомление.

**Почему**:
- Компонент `Cart` больше не содержит бизнес-логику оформления заказа и отвечает только за UI и пользовательские действия.
- Локальное состояние компонента (открытие корзины, кнопки) отделено от логики оформления заказа.
- Компонент стал чистым, переиспользуемым и легко тестируемым.

**Дополнительно**: в родительский компонент `AppContent` добавлен колбэк `handleCheckout`, который выполняет оформление заказа: показывает `alert`, очищает корзину через `clearCart` и имитирует асинхронную операцию через `setTimeout`. Этот колбэк передаётся в компонент `Cart` через пропс `onCheckout`. 

## Изменения в store.js
**Что сделано**:
1. Из состояния Redux удалены поля `cartCount`, `totalPrice`, `cartItemsCount`, `cartTotalAmount`, `cartTotalSum`.
2. В состоянии оставлено только содержимое корзины (`cart`) как источник данных.
3. Логика подсчёта количества товаров и общей суммы перенесена из reducers в селекторы.
4. Редьюсеры для работы с корзиной (`addToCart`, `removeFromCart`, `updateQuantity`, `clearCart`) упрощены - теперь они изменяют только `cart`.

**Почему**:
- Поля `cartCount`, `totalPrice`, `cartItemsCount`, `cartTotalAmount`, `cartTotalSum` всегда вычисляются из корзины, поэтому их хранение в сторе приводило к дублированию данных.
- В сторе было много повторяющегося кода с одинаковыми вычислениями.
- Стор стал проще, короче и легче для поддержки и расширения.
